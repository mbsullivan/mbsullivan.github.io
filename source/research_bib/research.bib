% Journal and Conference abbreviations

@string {AFIPSCSS = "Proceedings of the American Federation of Information Processing Societies National Computer Conference (AFIPS CSS)"}
@string {ALLERTON = "Annual Allerton Conference on Communication, Control, and Computing"}
@string {ARITH = "Proceedings of the IEEE Symposium on Computer Arithmetic"} 
@string {ASAP = "The International Conference on Application-specific Systems, Architectures and Processors (ASAP)"}
@string {ASILOMAR = "Proceedings of the Asilomar Conference on Signals and Systems"}
@string {ASPLOS = "Proceedings of the International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS)"}
@string {ATS = "Proceedings of the Asian Test Symposium (ATS)"}
@string {BELL = "Bell System Technical Journal" }
@string {CAL = "Computer Architecture Letters"}
@string {CASES = "Proceedings of the International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES)"}
@string {CCGRID = "IEEE/ACM International Symposium on Cluster, Cloud and Grid Computing (CCGrid)"}
@string {CGO = "Preceedings of the International Symposium on Code Generation and Optimization (CGO)"}
@string {CICC = "Proceedings of the Custom Integrated Circuits Conference (CICC)"}
@string {CLUSTER = "Proceedings of International Conference on Cluster Computing (CLUSTER)"}
@string {CODESISSS = "Proceedings of the International Conference on Hardware/Software Codesign and System Synthesis (CODES+ISSS)"}
@string {COMPCON = "Proceedings of the IEEE Computer Society International Conferrence (COMPCON)"}
@string {CPC = "Computer Physics Communications"}
@string {DAC = "Proceedings of the Design Automation Conference (DAC)"}
@string {DATE = "Proceedings of the Conference on Design, Automation, and Test in Europe (DATE)"}
@string {DFT = "Proceedings of the International Symposium on Defect and Fault Tolerance in VLSI Systems (DFT)"}
@string {DSD = "Proceedings of the Euromicro Conference on Digital System Design (DSD)"}
@string {DSN = "Proceedings of the International Conference on Dependable Systems and Networks (DSN)"}
@string {ECTC = "Proceedings of the Electronic Components and Technology Conference (ECTC)"}
@string {ETDC = "Proceedings of the European Design and Test Conference"}
@string {EUC = "Proceedings of the International Conference on Embedded and Ubiquitous Computing (EUC)"}
@string {FTCS = "Proceedings of the International Symposium on Fault-Tolerant Computing (FTCS)"}
@string {GTC = "GPU Technology Conference (GTC)"}
@string {HOTCHIPS = "Symposium on High Performance Chips (HOTCHIPS)"}
@string {HOTI = "Proceedings of the Symposium on Hot Interconnects"}
@string {HOTSTORAGE = "Proceedings of the USENIX conference on Hot topics in storage and file systems (Hot Storage)"}
@string {HPCA = "Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)"}
@string {HPDC = "Proceedings of the International Symposium on High-Performance Parallel and Distributed Computing (HPDC)"}
@string {IBMJRD = "IBM Journal of Research and Development"}
@string {IBMSJ = "IBM Systems Journal"}
@string {ICCAD = "Proceedings of Computer-Aided Design (ICCAD)"}
@string {ICCD = "Proceedings of the International Conference on Computer Design (ICCD)"} 
@string {ICDCS = "Proceedings of the International Conference on Distributed Computing Systems (ICDCS)"}
@string {ICTEM = "Proceedings of the International Convention on Information and Communication Technology, Electronics and Microelectronics"}
@string {IDT = "Proceedings of the International Design and Test Symposium (IDT)"}
@string {IEDM = "IEEE International Electron Devices Meeting"}
@string {IEECS = "IEE Journal on Circuits \& Systems"}
@string {IEEEDTC = "IEEE Design and Test of Computers"}
@string {IEEETC = "IEEE Transactions on Computers"}
@string {IEEETDM = "IEEE Transactions on Device and Materials Reliability"}
@string {IEEETIT = "IEEE Transactions on Information Theory"}
@string {IEEETNS = "IEEE Transactions on Nuclear Science"}
@string {IEEETR = "IEEE Transactions on Reliability"}
@string {IEEPC = "IEE Proceedings Communications"}
@string {IIRW = "Proceedings of the International Integrated Reliability Workshop (IIRW)"}
@string {IISWC = "Proceedings of the International Symposium on Workload Characterization"}
@string {IMCCC = "Proceedings of the International Conference on Instrumentation and Measurement, Computer, Communication and Control (IMCCC)"}
@string {INFOCOM = "Proceedings of the Inernational Conference on Computer Communication (INFOCOM)"}
@string {IOLTS = "Proceedings of the Online-Testing Symposium (IOLTS)"}
@string {IPDPS = "Proceedings of the International Symposium on Parallel and Distributed Processing (IPDPS)"}
@string {IPFA = "Proceedings of the International Symposium on Physical and Failure Analysis of Integrated Circuits (IPFA)"}
@string {IPL = "Information Processing Letters"}
@string {IRPS = "Proceedings of the International Reliability Physics Symposium (IRPS)"}
@string {ISC = "Proceedings of the International Supercomputing Conference (ISC)"}
@string {ISCA = "Proceedings of the International Symposium on Computer Architecture (ISCA)"}
@string {ISCAS = "Proceedings of the International Conference on Systems and Signals (ISCAS)"}
@string {ISIT = "Proceedings of the Inernational Symposium on Information Theory (ISIT)"}
@string {ISLPED = "Proceedings of the International Symposium on Low Power Electronics and Design (ISLPED)"}
@string {ISOCC = "Proceedings of the International SoC Design Conference (ISOCC)"}
@string {ISOCC = "Proceedings of the International SoC Design Conference (ISOCC)"}
@string {ISPASS = "Proceedings of the International Symposium on Performance Analysis of Systems and Software (ISPASS)"}
@string {ISQED = "Proceedings of the Symposium on Quality of Electronic Design (ISQED)"}
@string {ISSCC = "Proceedings of the International Solid State Circtuits Conference (ISSCC)"}
@string {ISSRE = "Proceedings of the International Symposium on Software Reliability Engineering (ISSRE)"}
@string {ISVLSI = "Proceedings of the IEEE Symposium on VLSI (ISVLSI)"} 
@string {ITC = "Proceedings of the International Test Conference (ITC)"}
@string {JACM = "Journal of the ACM"}
@string {JCV = "The International Journal of Computer Vision"}
@string {JHPCA = "The International Journal of High Performance Computing Applications"}
@string {JIC = "Journal of Information and Control (JIC)"}
@string {JSSC = "IEEE Journal of  Solid State Circuits"}
@string {LATW = "Proceedings of the Latin American Test Workshop (LATW)"}
@string {LCTES = "Proceedings of the Conference on Languages, Compilers, Tols, and Theory for Embedded Systems (LCTES)"}
@string {MEMF = "The Memory Forum"}
@string {MEMSYS = "Proceedings of the International Symposium on Memory Systems (MEMSYS)"}
@string {MICRO = "Proceedings of the International Symposium on Microarchitecture (MICRO)"}
@string {MICROMAG = "IEEE MICRO"}
@string {MIDDLEWARE = "Proceedings of the Annual Middleware Conference"}
@string {MMCS = "International Conference on Measurement and Modeling of Computer Systems"}
@string {OSDI = "Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)"}
@string {PACT = "Proceedings of the International Conference on Parallel Architectures and Compilation Techniques (PACT)"}
@string {PLDI = "Proceedings of the International Symposium on Programmaing Languages Design and Implementation (PLDI)"}
@string {PLDI = "Programming Languages Design and Implementation (PLDI)"}
@string {PPOPP = "Symposium on Principles and Practice of Parallel Programming (PPOPP)"}
@string {PRDC = "Proceedings of Pacific Rim International Symposium on Dependable Computing (PRDC)"}
@string {RECOSOC = "Proceedings of the International Symposium on Reconfigurable and Communication-Centric Systems-on-Chip (ReCoSoC)"}
@string {SAC = "Proceedings of the Symposium on Applied Computing (SAC)"}
@string {SBCCI = "Proceedings of the Symposium on Integrated Circuits and Systems Design (SBCCI)"}
@string {SC = "Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis (SC)"}
@string {SELSE = "Workshop on Silicon Errors in Logic--System Effects (SELSE)"}
@string {SIAM = "Journal of the Society for Industrial and Applied Mathmatics (SIAM)"}
@string {SIAP = "Journal of the Society for Industrial and Applied Mathematics"}
@string {SIGMETRICS = "Proceedings of the International Joint Conference on Measurement and Modeling of Computer Systems (SIGMETRICS)"}
@string {SOC = "Proceedings of the International Systems-on-Chip Conference (SoC)"}
@string {SOSP = "Proceedings of the Symposium on Operating Systems Principles (SOSP)"}
@string {TACO = "ACM Transactions on Architecture and Code Optimization (TACO)"}
@string {TASLP = "IEEE Transactions on Audio, Speech, and Language Processing"}
@string {TCAD = "IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems"}
@string {TDSC = "IEEE Transactions on Dependable and Secure Computing"}
@string {THREEDIC = "IEEE International 3D System Integration Conference (3DIC)"}
@string {TOPLAS = "ACM Transactions on Programming Languages and Systems (TOPLAS)"}
@string {USENIXATC = "Proceedings of the USENIX Annual Technical Conference (USENIX)"}
@string {VLSI = "IEEE Transactions on VLSI Systems (TVLSI)"}
@string {VLSISOC = "Proceedings of the International Conference on Very Large Scale Integration (VLSI-SoC)"}
@string {VLSIT = "Symposium on VLSI Technology (VLSIT)"}
@string {VTS = "Proceedings of the VLSI Test Symposium (VTS)"}
@string {WSP = "Proceedings of the Workshop on VLSI Signal Processing"}
@string {RADECS = "Proceedings of the European Conference on Radiation and Its Effects on Components and Systems (RADECS)"}
@string {EDTC = "Proceedings of the European Design and Test Conference (ED\&TC)"}
@string {ICM = "Proceedings of the International Conference on Microelectronics (ICM)"}
@string {TELSIKS = "Proceedings of the International Conference on Telecommunication in Modern Satellite, Cable and Broadcasting Services (TELSIKS)"}
@string {JTEST = "Journal of Electronic Testing"}

@string {END = ""}

% bibtex entries

% nopdf

@INPROCEEDINGS {chung2012cds,
    AUTHOR = {Jinsuk Chung and Ikhwan Lee and Michael Sullivan and Jee Ho Ryoo and Dong Wan Kim and Doe Hyun Yoon and Larry Kaplan and Mattan Erez},
    TITLE = {Containment {D}omains: {A} Scalable, Efficient, and Flexible Resilience Scheme for {E}xascale Systems},
    BOOKTITLE = SC,
    YEAR = {2012},
    PAGES = {1--11},
    ABSTRACT = {This paper describes and evaluates a scalable and  efficient resilience scheme based on the concept of containment domains. Containment domains are a programming construct that enable applications to express resilience needs and to interact with the system to tune and specialize error detection, state preservation and restoration, and recovery schemes. Containment domains have weak transactional semantics and are nested to take advantage of the machine and application hierarchies and to enable hierarchical state preservation, restoration, and recovery. We evaluate the scalability and efficiency of containment domains using generalized trace-driven simulation and analytical analysis and show that containment domains are superior to both checkpoint restart and redundant execution approaches.},
    CATEGORIES = {sys, rel},
    NOTES = {Nominee for the best paper award.},
}

@INPROCEEDINGS {yoon2012dgms,
    AUTHOR = {Doe Hyun Yoon and Min Kyu Jeong and Michael B. Sullivan and Mattan Erez},
    TITLE = {The Dynamic Granularity Memory System},
    BOOKTITLE = ISCA,
    YEAR = {2012},
    PAGES = {548--559},
    ABSTRACT = {Chip multiprocessors enable continued performance scaling with increasingly many cores per chip. As the throughput of computation outpaces available memory bandwidth, however, the system bottleneck will shift to main memory. We present a memory system, the dynamic granularity memory system (DGMS), which avoids unnecessary data transfers, saves power, and improves system performance by dynamically changing between fine and coarse grained memory accesses. DGMS predicts memory access granularities dynamically in hardware, and does not require software or OS support. The dynamic operation of DGMS gives it superior ease of implementation and power efficiency relative to prior multi-granularity memory systems, while maintaining comparable levels of system performance.},
    CATEGORIES = {micro, mem},
}

@ARTICLE{yoon2013proportional_mem_sys,
    AUTHOR = {Doe Hyun Yoon and Min Kyu Jeong and Michael Sullivan and Mattan Erez},
    TITLE = {Towards Proportional Memory Systems},
    JOURNAL = {Intel Technology Journal},
    VOLUME = {17},
    ISSUE = {1},
    PAGES = {118--139},
    YEAR = {2012},
    ABSTRACT = {Off-chip memory systems are currently designed to present a uniform interface to the processor. Applications and systems, however, have dynamic and heterogeneous requirements in terms of reliability and access granularity because of complex usage scenarios and differing spatial locality. We argue that memory systems should be proportional, in that the data transferred and overhead of error protection be proportional to the requirements and characteristics of the running processes. We describe two techniques and specific designs for achieving aspects of proportionality in the main memory system. The first, dynamic and adaptive granularity, utilizes conventional DRAM chips with minor DIMM modifications (along with new control and prediction mechanisms) to access memory with either fine or coarse granularity depending on observed spatial locality. The second, virtualized ECC, is a software/hardware collaborative technique that enables flexible, dynamic, and adaptive tuning between the level of protection provided for a virtual memory page and the overhead of bandwidth and capacity for achieving protection. Both mechanisms have a small hardware overhead, can be disabled to match the baseline, and provide significant benefits when in use.},
    CATEGORIES = {sys, micro, mem},
    URL = {https://noggin.intel.com/content/paper-7-towards-proportional-memory-systems},
}

@TECHREPORT{lee2012sef,
    AUTHOR = {Ikhwan Lee and Michael Sullivan and Evgeni Krimer and Dong Wan Kim and Mehmet Basoglu and Doe Hyun Yoon and Larry Kaplan and Mattan Erez},
    TITLE = {Survey of Error and Fault Detection Mechanisms v2},
    NUMBER = {TR-LPH-2012-001},
    INSTITUTION = {LPH Group, Department of Electrical and Computer Engineering, The University of Texas at Austin},
    YEAR = {Updated 2012},
    ABSTRACT = {This report describes diverse error detection mechanisms that can be utilized within a resilient system to protect applications against various types of errors and faults, both hard and soft. These detection mechanisms have different overhead costs in terms of energy, performance, and area, and also differ in their error coverage, complexity, and programmer effort.

In order to achieve the highest efficiency in designing and running a resilient computer system, one must understand the trade-offs among the aforementioned metrics for each detection mechanism and choose the most efficient option for a given running environment. To accomplish such a goal, we first enumerate many error detection techniques previously suggested in the literature.},
    CATEGORIES = {sys, rel, arith, mem},
}

@TECHREPORT{sullivan2011cds,
    AUTHOR = {Sullivan, Michael and Yoon, Doe Hyun and Erez, Mattan},
    TITLE = {Containment Domains: A Full-System Approach to Computational Resiliency},
    NUMBER = {TR-LPH-2011-001},
    INSTITUTION = {LPH Group, Department of Electrical and Computer Engineering, The University of Texas at Austin},
    YEAR = {2011},
    ABSTRACT = {Operating the Echelon system at optimal energy efficiency under a wide range of environmental conditions and operating scenarios requires a comprehensive and flexible resiliency solution. Our research is focused in on two main directions: providing mechanisms for proportional resiliency which use application-tunable hardware/software cooperative error detection and recovery, and enabling hierarchical state preservation and restoration as an alternative to non-scalable and inefficient generic checkpoint and restart. As an interface to these orthogonal research areas, we are developing and evaluating programming constructs based on the concept of Containment Domains. Containment Domains enable the programmer and software system to interact with the hardware and establish a hierarchical organization for preserving necessary state, multi-granularity error detection, and minimal re-execution. Containment domains also empower the programmer to reason about resiliency and utilize domain knowledge to improve efficiency beyond what compiler analysis can achieve without such information. This report describes our initial framework and focuses more on the aspects relating to enabling efficient state preservation and restoration.},
    CATEGORIES = {sys, rel},
}

@INPROCEEDINGS{sullivan2013cpcf,
    AUTHOR = {Sullivan, Michael B. and Swartzlander, Earl E.},
    BOOKTITLE = ASILOMAR, 
    TITLE = {On Separable Error Detection for Addition},
    YEAR = {2013},
    PAGES = {2181--2186},
    ABSTRACT = {Addition is ubiquitous in computer systems, and rising error rates make error detection within adders increasingly important. This paper considers the best way to introduce strong, non-intrusive error detection to fixed-point addition within an existing, optimized machine datapath. A flexible family of separable error detection techniques called carry-propagate/carry-free (CP/CF) duplication is presented that offer superior error detection efficiency for a variety of adders.},
    CATEGORIES = {rel, arith},
}

@INPROCEEDINGS{sullivan2011hrg,
    AUTHOR = {Sullivan, Michael B. and Swartzlander, Earl E.},
    BOOKTITLE = ASILOMAR, 
    TITLE = {Hybrid Residue Generators for Increased Efficiency},
    YEAR = {2011},
    PAGES = {144--148},
    ABSTRACT = {In order for residue checking to effectively protect computer arithmetic, designers must be able to efficiently compute the residues of the input and output signals of functional units. Low-cost, single-cycle residue generators can be readily formed out of two’s complement adders in two ways, which have area and delay tradeoffs. A residue generator using adderincrementers for end-around-carry adders is small but slow, and a design using carry-select adders is fast, but large. It is shown that a hybrid combination of both approaches is more efficient than either.},
    CATEGORIES = {arith},
}

@INPROCEEDINGS{sullivan2012lrc,
    AUTHOR = {Sullivan, Michael B. and Swartzlander, Earl E.},
    BOOKTITLE = ASAP, 
    TITLE = {Long Residue Checking for Adders},
    YEAR = {2012},
    PAGES = {177--180},
    ABSTRACT = {As system sizes grow and devices become more sensitive to faults, adder protection may be necessary to achieve system error-rate bounds. This study investigates a novel fault detection scheme for fast adders, long residue checking (LRC), which has substantive advantages over all previous separable approaches. Long residues are found to provide a ~10\% reduction in complexity and ~25\% reduction in power relative to the next most efficient error detector, while remaining modular and easy to implement.},
    CATEGORIES = {rel, arith},
}

@INPROCEEDINGS{sullivan2012tecmul,
    AUTHOR = {Sullivan, Michael B. and Swartzlander, Earl E.},
    BOOKTITLE = ASILOMAR, 
    TITLE = {Truncated Error Correction for Flexible Approximate Multiplication},
    YEAR = {2012},
    PAGES = {355--359},
    ABSTRACT = {Binary logarithms can be used to perform computer multiplication through simple addition. Exact logarithmic (and anti-logarithmic) conversion is prohibitively expensive for use in general multipliers; however, inexpensive estimate conversions can be used to perform approximate multiplication. Such approximate multipliers have been used in domain-specific applications, but existing designs either offer superior efficiency or flexibility. This study proposes a flexible approximate multiplier with improved efficiency. Preliminary analysis indicates that this design provides up to a 50\% efficiency advantage relative to prior flexible approximate multipliers.},
    CATEGORIES = {arith, approx},
}

@INPROCEEDINGS{sullivan2013tlga,
    AUTHOR = {Sullivan, Michael B. and Swartzlander, Earl E.},
    BOOKTITLE = ARITH, 
    TITLE = {Truncated Logarithmic Approximation},
    YEAR = {2013},
    PAGES = {191--198},
    ABSTRACT = {The speed and levels of integration of modern devices have risen to the point that arithmetic can be performed very fast and with high precision. Precise arithmetic comes at a hidden cost--by computing results past the precision they require, systems inefficiently utilize their resources. Numerous designs over the past fifty years have demonstrated scalable efficiency by utilizing approximate logarithms. Many such designs are based off of a linear approximation algorithm developed by Mitchell. This paper evaluates a truncated form of binary logarithm as a replacement for Mitchell's algorithm. The <i>truncated approximate logarithm</i> simultaneously improves the efficiency and precision of Mitchell's approximation while remaining simple to implement.},
    CATEGORIES = {arith, approx},
}

@INPROCEEDINGS{jeong2012bpart,
    AUTHOR = {Min Kyu Jeong and Doe Hyun Yoon and Dam Sunwoo and Michael Sullivan and Ikhwan Lee and Mattan Erez},
    TITLE = {Balancing {DRAM} Locality and Parallelism in Shared Memory {CMP} Systems},
    BOOKTITLE = HPCA,
    YEAR = {2012},
    PAGES = {1--12},
    ABSTRACT = {Modern memory systems rely on spatial locality to provide high bandwidth while minimizing memory device power and cost. The trend of increasing the number of cores that share memory, however, decreases apparent spatial locality because access streams from independent threads are interleaved. Memory access scheduling recovers only a fraction of the original locality because of buffering limits. We investigate new techniques to reduce inter-thread access interference. We propose to partition the internal memory banks between cores to isolate their access streams and eliminate locality interference. We implement this by extending the physical frame allocation algorithm of the OS such that physical frames mapped to the same DRAM bank can be exclusively allocated to a single thread. We compensate for the reduced bank-level parallelism of each thread by employing memory sub-ranking to effectively increase the number of independent banks. This combined approach, unlike memory bank partitioning or sub-ranking alone, simultaneously increases overall performance and significantly reduces memory power consumption.},
    CATEGORIES = {sys, mem},
}

@INPROCEEDINGS {rhu2013lamar,
    AUTHOR = {Minsoo Rhu and Michael Sullivan and Jingwen Leng and Mattan Erez},
    TITLE = {A Locality-Aware Memory Hierarchy for Energy-Efficient GPU Architectures},
    BOOKTITLE = MICRO,
    YEAR = {2013},
    PAGES = {86--98},
    ABSTRACT = {As GPU's compute capabilities grow, their memory hierarchy increasingly becomes a bottleneck. Current GPU memory hierarchies use coarse-grained memory accesses to exploit spatial locality, maximize peak bandwidth, simplify control, and reduce cache meta-data storage. These coarse-grained memory accesses, however, are a poor match for emerging GPU applications with irregular control flow and memory access patterns. Meanwhile, the massive multi-threading of GPUs and the simplicity of their cache hierarchies make CPU-specific memory system enhancements ineffective for improving the performance of irregular GPU applications. We design and evaluate a locality-aware memory hierarchy for throughput processors, such as GPUs. Our proposed design retains the advantages of coarse-grained accesses for spatially and temporally local programs while permitting selective fine-grained access to memory. By adaptively adjusting the access granularity, memory bandwidth and energy are reduced for data with low spatial/temporal locality without wasting control overheads or prefetching potential for data with high spatial locality. As such, our locality-aware memory hierarchy improves GPU performance, energy-efficiency, and memory throughput for a large range of applications.},
    CATEGORIES = {micro, mem},
}

@INPROCEEDINGS{willert2012hybrid,
    TITLE = {Hybrid Deterministic/Monte Carlo Neutronics Using {GPU} Accelerators},
    AUTHOR = {Jeff Willert and CT Kelley and DA Knoll and Han Dong and Mahesh Ravishankar and Paul Sathre and Michael Sullivan and William Taitano},
    BOOKTITLE = DCABES,
    PAGES = {43--47},
    YEAR = {2012},
    ABSTRACT = {In this paper we discuss a GPU implementation of a hybrid deterministic/Monte Carlo method for the solution of the neutron transport equation. The key feature is using GPUs to perform a Monte Carlo transport sweep as part of the evaluation of the nonlinear residual and Jacobian-vector product. We describe the algorithm and present some preliminary numerical results which illustrate the effectiveness of the GPU Monte Carlo sweeps.},
    CATEGORIES = {},
}


@INPROCEEDINGS{kim2015bamboo,
    TITLE = {Bamboo {ECC}: {S}trong, Safe, and Flexible Codes for Reliable Computer Memory},
    AUTHOR = {Jungrae Kim and Michael Sullivan and Mattan Erez},
    BOOKTITLE = HPCA,
    YEAR = {2015},
    ABSTRACT = {Growing computer system sizes and levels of integration have made memory reliability a primary concern, necessitating strong memory error protection. As such, large-scale systems typically employ error checking and correcting codes to trade redundant storage and bandwidth for increased reliability. While stronger memory protection will be needed to meet reliability targets in the future, it is undesirable to further increase the amount of storage and bandwidth spent on redundancy. We propose a novel family of single-tier ECC mechanisms called Bamboo ECC to simultaneously address the conflicting requirements of increasing reliability while maintaining or decreasing error protection overheads.

Relative to the state-of-the-art single-tier error protection, Bamboo ECC codes have superior correction capabilities, all but eliminate the risk of silent data corruption, and can also increase redundancy at a fine granularity, enabling more adaptive graceful downgrade schemes. These strength, safety, and flexibility advantages translate to a significantly more reliable memory system. To demonstrate this, we evaluate a family of Bamboo ECC organizations in the context of conventional 72b and 144b DRAM channels and show the significant error coverage and memory lifespan improvements of Bamboo ECC relative to existing SEC-DED, chipkill-correct and double-chipkill-correct schemes.},
    CATEGORIES = {mem, rel},
    NOTES = {Nominee for the best paper award.},
}


@INPROCEEDINGS{sullivan2015lcmult,
    AUTHOR = {Sullivan, Michael B. and Swartzlander, Earl E.},
    BOOKTITLE = ARITH, 
    TITLE = {Low-Cost Duplicate Multiplication},
    YEAR = {2015},
    CATEGORIES = {arith, rel},
    ABSTRACT = {Rising levels of integration, decreasing component reliabilities, and the ubiquity of computer systems make error protection a rising concern. Meanwhile, the uncertainty of future fault and error modes motivates the design of strong error detection mechanisms that offer fault-agnostic error protection. Current concurrent hardware mechanisms, however, either offer strong error detection coverage at high cost, or restrict their coverage to narrow synthetic error modes. This paper investigates the potential for duplication using alternate number systems to lower the costs of duplicated multiplication without sacrificing error coverage. An example of such a low-cost duplication scheme is described and evaluated; it is shown that specialized carry-save checking can be used to increase the efficiency of duplicated multiplication.},
}

@ARTICLE{chung2013cds_sp,
    AUTHOR = {Jinsuk Chung and Ikhwan Lee and Michael Sullivan and Jee Ho Ryoo and Dong Wan Kim and Doe Hyun Yoon and Larry Kaplan and Mattan Erez},
    TITLE = {Containment {D}omains: {A} Scalable, Efficient, and Flexible Resilience Scheme for {E}xascale Systems },
    JOURNAL = {Scientific Programming},
    VOLUME = {21},
    NUMBER = {3},
    PAGES = {197--212},
    YEAR = {2013},
    ABSTRACT = {This paper describes and evaluates a scalable and  efficient resilience scheme based on the concept of containment domains. Containment domains are a programming construct that enable applications to express resilience needs and to interact with the system to tune and specialize error detection, state preservation and restoration, and recovery schemes. Containment domains have weak transactional semantics and are nested to take advantage of the machine and application hierarchies and to enable hierarchical state preservation, restoration, and recovery. We evaluate the scalability and efficiency of containment domains using generalized trace-driven simulation and analytical analysis and show that containment domains are superior to both checkpoint restart and redundant execution approaches.},
    CATEGORIES = {sys, rel},
}

@ARTICLE{powell2008nanoprecipitation,
    TITLE = {Nanoprecipitation-Assisted Ion Current Oscillations},
    AUTHOR = {Powell, Matthew R and Sullivan, Michael and Vlassiouk, Ivan and Constantin, Dragos and Sudre, Olivier and Martens, Craig C and Eisenberg, Robert S and Siwy, Zuzanna S},
    JOURNAL = {Nature Nanotechnology},
    VOLUME = {3},
    NUMBER = {1},
    PAGES = {51--57},
    YEAR = {2008},
    PUBLISHER = {Nature Publishing Group}
    CATEGORIES = {},
    URL = {http://www.nature.com/nnano/journal/v3/n1/full/nnano.2007.420.html},
    ABSTRACT = {Nanoscale pores exhibit transport properties that are not seen in micrometre-scale pores, such as increased ionic concentrations inside the pore relative to the bulk solution, ionic selectivity and ionic rectification. These nanoscale effects are all caused by the presence of permanent surface charges on the walls of the pore. Here we report a new phenomenon in which the addition of small amounts of divalent cations to a buffered monovalent ionic solution results in an oscillating ionic current through a conical nanopore. This behaviour is caused by the transient formation and redissolution of nanoprecipitates, which temporarily block the ionic current through the pore. The frequency and character of ionic current instabilities are regulated by the potential across the membrane and the chemistry of the precipitate. We discuss how oscillating nanopores could be used as model systems for studying nonlinear electrochemical processes and the early stages of crystallization in sub-femtolitre volumes. Such nanopore systems might also form the basis for a stochastic sensor.},
    SECTION = {Other},
}

@INPROCEEDINGS{kim2015frugal,
    TITLE = {Frugal {ECC}: {E}fficient and Versatile Memory Error Protection through Fine-Grained Compression},
    AUTHOR = {Jungrae Kim and Michael Sullivan and Seong-Lyong Gong and Mattan Erez},
    BOOKTITLE = SC,
    YEAR = {2015},
    CATEGORIES = {mem, rel},
    ABSTRACT = {Because main memory is vulnerable to errors and failures, large-scale systems and critical servers utilize error checking and correcting (ECC) mechanisms to meet their reliability requirements. We propose a novel mechanism, Frugal ECC (FECC), that combines ECC with fine-grained compression to provide versatile protection that can be both stronger and lower overhead than current schemes, without sacrificing performance. FECC compresses main memory at cache-block granularity, using any left over space to store ECC information. Compressed data and its ECC information are then frequently read with a single access even without redundant memory chips; blocks that do not compress sufficiently require additional storage and accesses.  As examples of FECC, we present chipkill-correct and chipkill-level ECCs on a 64-bit non-ECC DIMM with ×4 DRAM chips. We also describe the first true chipkill-correct ECC for ×8 devices using conventional ECC DIMMs. FECC relies on a new Coverage-oriented Compression (CoC) scheme that we developed specifically for the modest compression needs of ECC and for floating-point data. CoC can sufficiently compress 84\% of all accesses in SPEC Int, 93\% in SPEC FP, 95\% in SPLASH2X, and nearly 100\% in the NPB suites. With such high compression coverage, the worst case performance degradation from FECC is less than 3.7\% while reliability is slightly improved and energy consumption reduced by about 50\% for true chipkill-correct.},
}

@INPROCEEDINGS{kim2016aiecc,
    TITLE = {{All-Inclusive ECC}: {T}horough End-to-End Protection for Reliable Computer Memory},
    AUTHOR = {Jungrae Kim and Michael Sullivan and Sangkug Lym and Mattan Erez},
    BOOKTITLE = ISCA,
    YEAR = {2016},
    CATEGORIES = {mem, rel},
    ABSTRACT = {Increasing transfer rates and decreasing I/O voltage levels make signals more vulnerable to transmission errors. While the data in computer memory are well-protected by modern error checking and correcting (ECC) codes, the clock, control, command, and address (CCCA) signals are weakly protected or even unprotected such that transmission errors leave serious gaps in data-only protection. This paper presents All-Inclusive ECC (AIECC), a memory protection scheme that leverages and augments data ECC to also thoroughly protect CCCA signals. AIECC provides strong end-to-end protection of memory, detecting nearly 100\% of CCCA errors and also preventing transmission errors from causing latent memory data corruption. AIECC provides these system-level benefits without requiring extra storage and transfer overheads and without degrading the effective level of data protection.},
}

@INPROCEEDINGS{kim2016bpc,
    TITLE = {{Bit-Plane Compression}: {T}ransforming Data for Better Compression in Many-core Architectures},
    AUTHOR = {Jungrae Kim and Michael Sullivan and Esha Choukse and Mattan Erez},
    BOOKTITLE = ISCA,
    YEAR = {2016},
    CATEGORIES = {sys, micro, mem},
    ABSTRACT = {As key applications become more data-intensive and the computational throughput of processors increases, the amount of data to be transferred in modern memory subsystems grows. Increasing physical bandwidth to keep up with the demand growth is challenging, however, due to strict area and energy limitations. This paper presents a novel and lightweight compression algorithm, Bit-Plane Compression (BPC) , to increase the effective memory bandwidth. BPC aims at homogeneously-typed memory blocks, which are prevalent in many-core architectures, and applies a smart data transformation to both improve the inherent data compressibility and to reduce the complexity of compression hardware. We demonstrate that BPC provides superior compression ratios of 4.1:1 for integer benchmarks and reduces memory bandwidth requirements significantly.},
}

@INPROCEEDINGS{sullivan2016hardening,
    TITLE = {An Analytical Model for Hardened Latch Selection and Exploration},
    AUTHOR = {Michael Sullivan and Brian Zimmer and Siva Hari and Timothy Tsai and Stephen W. Keckler},
    BOOKTITLE = SELSE,
    YEAR = {2016},
    CATEGORIES = {sys, rel},
    ABSTRACT = {Hardened flip-flops and latches are designed to be resilient to soft errors, maintaining high system reliability in the presence of energetic radiation. The wealth of different hardened designs (with varying protection levels) and the probabilistic nature of reliability complicates the choice of which hardened storage element to substitute where. This paper develops an analytical model for hardened latch and flip-flop design space exploration. It is shown that the best hardened design depends strongly on the target protection level and the chip that is being protected. Also, the use of multiple complementary hardened cells can combine the relative advantages of each design, garnering significant efficiency improvements in many situations.},
    SECTION = {Other},
}

@INPROCEEDINGS{li2017understanding,
    AUTHOR = {Li, Guanpeng and Hari, Siva Kumar Sastry and Sullivan, Michael and Tsai, Timothy and Pattabiraman, Karthik and Emer, Joel and Keckler, Stephen W},
    TITLE = {Understanding Error Propagation in Deep Learning Neural Network ({DNN}) Accelerators and Applications},
    BOOKTITLE = SC,
    YEAR = {2017},
    CATEGORIES = {sys, rel},
    ABSTRACT = {Deep learning neural networks (DNNs) have been successful in solving a wide range of machine learning problems. Specialized hardware accelerators have been proposed to accelerate the execution of DNN algorithms for high-performance and energy efficiency.  Recently, they have been deployed in datacenters (potentially for business-critical or industrial applications) and safety-critical systems such as self-driving cars. Soft errors caused by high-energy particles have been increasing in hardware systems, and these can lead to catastrophic failures in DNN systems. Traditional methods for building resilient systems, e.g., Triple Modular Redundancy (TMR), are agnostic of the DNN algorithm and the DNN accelerator’s architecture. Hence, these traditional resilience approaches incur high overheads, which makes them challenging to deploy. In this paper, we experimentally evaluate the resilience characteristics of DNN systems (i.e., DNN software running on specialized accelerators). We find that the error resilience of a DNN system depends on the data types, values, data reuses, and types of layers in the design. Based on our observations, we propose two efficient protection techniques for DNN systems.},
}

@INPROCEEDINGS{gong2017duo,
    AUTHOR = {Seong-Lyong Gong and Jungrae Kim and Sangkug Lym and Michael Sullivan and Howard David and Mattan Erez},
    TITLE = {{DUO}: {Exposing} On-chip Redundancy to Rank-Level {ECC} for High Reliability},
    BOOKTITLE = HPCA,
    YEAR = {2018},
    CATEROGIES = {mem, rel},
    ABSTRACT = {DRAM row and column sparing cannot efficiently tolerate the increasing inherent fault rate caused by continued process scaling. In-DRAM ECC (IECC), an appealing alternative to sparing, can resolve inherent faults without significant changes to DRAM, but it is inefficient for highly-reliable systems where rank-level ECC (RECC) is already used against operational faults. In addition, DRAM design in the near future (possibly as early as DDR5) may transfer data in longer bursts, which complicates high-reliability RECC due to fewer devices being used per rank and increased fault granularity.  We propose dual use of on-chip redundancy (DUO), a mechanism that bypasses the IECC module and transfers on-chip redundancy to be used directly for RECC. Due to its increased redundancy budget, DUO enables a strong and novel RECC for highly-reliable systems, called DUO SDDC. The long codewords of DUO SDDC provide fundamentally higher detection and correction capabilities, and several novel secondary-correction techniques integrate together to further expand its correction capability. According to our evaluation results, DUO shows performance degradation on par with or better than IECC (average 2--3\%), while consuming less DRAM energy than IECC (average 4--14\% overheads). DUO provides higher reliability than either IECC or the state-of-the-art ECC technique.We show the robust reliability of DUO SDDC by comparing it to other ECC schemes using two different inherent fault-error models.},
}

@INPROCEEDINGS{li2018modeling,
    title={Modeling Soft-Error Propagation in Programs},
    author={Li, Guanpeng and Pattabiraman, Karthik and Hari, Siva Kumar Sastry and Sullivan, Michael and Tsai, Timothy},
    booktitle=DSN,
    year={2018},
    CATEGORIES = {sys, rel},
    ABSTRACT = {As technology scales to lower feature sizes, devices become more susceptible to soft errors. Soft errors can lead to silent data corruptions (SDCs), seriously compromising the reliability of a system. Traditional hardware-only techniques to avoid SDCs are energy hungry, and hence not suitable for commodity systems. Researchers have proposed selective software-based protection techniques to tolerate hardware faults at lower costs. However, these techniques either use expensive fault injection or inaccurate analytical models to determine which parts of a program must be protected for preventing SDCs.  In this work, we construct a three-level model, TRIDENT , that captures error propagation at the static data dependency, control- flow and memory levels, based on empirical observations of error propagations in programs. TRIDENT is implemented as a compiler module, and it can predict both the overall SDC probability of a given program and the SDC probabilities of individual instructions, without fault injection. We find that TRIDENT is nearly as accurate as fault injection and it is much faster and more scalable. We also demonstrate the use of TRIDENT to guide selective instruction duplication to efficiently mitigate SDCs under a given performance overhead bound.},
    NOTES = {Runner-up for the best paper award.},
    NOPDF = {},
}

@INPROCEEDINGS{mahmoud2018sinrg,
    title={Optimizing Software-Directed Instruction Replication for {GPU} Error Detection},
    author={Abdulrahman Mahmoud and Siva Hari and Michael Sullivan and Tim Tsai and Stephen W. Keckler},
    booktitle=SC,
    year={2018},
    CATEGORIES = {sys, rel},
    ABSTRACT = {Application execution on safety-critical and high-performance computer systems must be resilient to transient errors. As GPUs become more pervasive in such systems, they must supplement ECC/parity for major storage structures with reliability techniques that cover more of the GPU hardware logic. Instruction duplication has been explored for CPU resilience; however, it has never been studied in the context of GPUs, and it is unclear whether the performance and design choices it presents makes it a feasible GPU solution. This paper describes a practical methodology to employ instruction duplication for GPUs and identifies implementation challenges that can incur high overheads (69\% on average). It explores GPU-specific software optimizations that trade fine-grained recoverability for performance. It also proposes simple ISA extensions with limited hardware changes and area costs to further improve performance, cutting the runtime overheads by more than half to an average of 30\%.}, 
    NOPDF = {}, 
} 

@INPROCEEDINGS{garg2018crum,
    title={{CRUM}: Checkpoint-Restart Support for {CUDA}'s Unified Memory},
    author={Rohan Garg and Apoorve Mohan and Michael Sullivan and Gene Cooperman},
    booktitle=CLUSTER,
    year={2018},
    CATEGORIES = {sys, rel},
    ABSTRACT = {Unified Virtual Memory (UVM) was recently introduced on recent NVIDIA GPUs. Through software and hardware support, UVM provides a coherent shared memory across the entire heterogeneous node, migrating data as appropriate. The older CUDA programming style is akin to older large-memory UNIX applications which used to directly load and unload memory segments. Newer CUDA programs have started taking advantage of UVM for the same reasons of superior programmability that UNIX applications long ago switched to assuming the presence of virtual memory. Therefore, checkpointing of UVM will become increasingly important, especially as NVIDIA CUDA continues to gain wider popularity: 87 of the top 500 supercomputers in the latest listings are GPU-accelerated, with a current trend often additional GPU-based supercomputers each year. 
        
A new scalable checkpointing mechanism, CRUM (Checkpoint-Restart for Unified Memory), is demonstrated for hybrid CUDA/MPI computations across multiple computer nodes. CRUM supports a fast, forked checkpointing, which mostly overlaps the CUDA computation with storage of the checkpoint image in stable storage. The runtime overhead of using CRUM is 6\% on average, and the time for forked checkpointing is seen to be a factor of up to 40 times less than traditional, synchronous checkpointing.},
    NOPDF = {},
}

@ARTICLE{sullivan2018swapcodes,
	title={{SwapCodes}: {Error} Codes for Hardware-Software Cooperative {GPU} Pipeline Error Detection},
	author={Michael B. Sullivan, Siva Hari, Brian Zimmer, Timothy Tsai, and Stephen W. Keckler},
	booktitle=MICRO,
	year={2018},
	CATEGORIES = {sys, rel},
	ABSTRACT = {Intra-thread instruction duplication offers straightforward and effective pipeline error detection for data-intensive processors. However, software-enforced instruction duplication uses explicit checking instructions, roughly doubles program register usage, and doubles the number of arithmetic operations per thread, potentially leading to severe slowdowns. This paper investigates SwapCodes, a family of software-hardware cooperative mechanisms to accelerate intra-thread duplication in GPUs. SwapCodes leverages the register file ECC hardware to detect pipeline errors without sacrificing the ability of ECC to detect and correct storage errors. By implicitly checking for pipeline errors on each register read, SwapCodes avoids the overheads of instruction checking without adding new hardware error checkers or buffers. We describe a family of SwapCodes implementations that successively eliminate the sources of inefficiency in intra-thread duplication with different complexities and error detection and correction trade-offs.We apply SwapCodes to protect a GPU based processor against pipeline errors, and demonstrate that it is able to detect more than 99.3\% of pipeline errors while improving performance and system efficiency relative to software-enforced duplication—the most performant SwapCodes organizations incur just 15\% average slowdown over the un-duplicated program.},
	NOPDF = {},
}

@ARTICLE{chang2018hamartia,
	title={{Hamartia}: {A} Fast and Accurate Error Injection Framework},
	author={Chun-Kai Chang and Sangkug Lym and Nicholas Kelly and Michael B. Sullivan and Mattan Erez},
	booktitle=DSN,
	year={2018},
	CATEGORIES = {sys, rel},
	ABSTRACT = {Single bit-flip has been the most popular error model for resilience studies with fault injection. We use RTL gate-level fault injection to show that this model fails to cover many realistic hardware faults. Specifically, single-event transients from combinational logic and single-event upsets in pipeline latches can lead to complex multi-bit errors at the architecture level. However, although accurate, RTL simulation is too slow to evaluate application-level resilience. To strike a balance between model accuracy and injection speed, we refine the concept of hierarchical injection to prune faults with known outcomes, saving 62\% of program runs at 2\% margin of error on average across 9 benchmark programs. Our implementation of the hierarchical error injector is not only accurate but also fast because it is able to source realistic error patterns using on demand RTL gate-level fault injection. Our tool outperforms state-of-the-art assembly-level and compiler-based error injectors by up to 6X, while providing higher fidelity.},
	NOPDF = {},
}

@ARTICLE{chang2018hpcinject,
    title={Evaluating and Accelerating High-Fidelity Error Injection for {HPC}},
    author={Chun-Kai Chang and Sangkug Lym and Nicholas Kelly and Michael B. Sullivan and Mattan Erez},
    booktitle=SC,
    year={2018},
    CATEGORIES = {sys, rel},
    ABSTRACT = {We address two important concerns in the analysis of the behavior of applications in the presence of hardware errors: (1) when is it important to model how hardware faults lead to erroneous values (instruction-level errors) with high fidelity, as opposed to using simple bit-flipping models, and (2) how to enable fast high-fidelity error injection campaigns, in particular when error detectors are employed. We present and verify a new nested Monte Carlo methodology for evaluating high-fidelity gate-level fault models and error-detector coverage, which is orders of magnitude faster than current approaches. We use that methodology to demonstrate that, without detectors, simple error models suffice for evaluating errors in 9 HPC benchmarks.},
    NOPDF = {},
}
